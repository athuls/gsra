/***************************************************************************
 *   Copyright (C) 2008 by Yann LeCun and Pierre Sermanet *
 *   yann@cs.nyu.edu, pierre.sermanet@gmail.com *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Redistribution under a license not approved by the Open Source
 *       Initiative (http://www.opensource.org) must display the
 *       following acknowledgement in all advertising material:
 *        This product includes software developed at the Courant
 *        Institute of Mathematical Sciences (http://cims.nyu.edu).
 *     * The names of the authors may not be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ThE AUTHORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ***************************************************************************/

#ifndef SDNN_MODULES_H_
#define SDNN_MODULES_H_

#include "libidx.h"
#include "net_cscscfe.h"

namespace ebl {

/*   //! a special kind of state used to store the output of a classifier. */
/*   //! sdnnclass-state are generated by modules such as class-max, and used */
/*   //! by meters such as classifier-meter. No backprop is possible through  */
/*   //! a sdnnclass-state. */
/*   class sdnnclass_state */
/*   { */
/*   public: */
/*     int				output_class; */
/*     double 			confidence; */
/*     idx<int>		*sorted_classes; */
/*     idx<double>		*sorted_scores; */

/*     sdnnclass_state(int n); */

/*     virtual ~sdnnclass_state(); */
/*   }; */

/*   ////////////////////////////////////////////////////////////////////////////// */

/*   //! a classifier that computes class scores based on  */
/*   //! an mmi type criterion (a kind of softmax in log) */
/*   //! It gives scores (cost) for all classes including junk. */
/*   //! It should be used in conjunction with sdnn-cost. */
/*   //! This assumes that the output of the previous module */
/*   //! are costs, or negative log likelihoods. */
/*   //! this modules accepts spatially replicated inputs. */
/*   template <class T> class sdnn_classer */
/*   { */
/*   public: */
/*     //! a vector that maps output unit index to a label */
/*     idx<int>	        *classindex2label; */
/*     state_idx<T>	*junk_param; */
/*     state_idx<T>	*logadded_distjunk; */
/*     idx<double>	        *priors; */

/*     //! makes a new sdnn-classer. The arguments are identical */
/*     //! to that of sdnn-cost. In fact if an sdnn-classer is to */
/*     //! used in conjunction with an mmi-cost, they should share */
/*     //! the prior vector and the parameter. */
/*     //! sharing the parameter can be done by first building the */
/*     //! classer, then reducing the size of the parameter by one, */
/*     //! then creating the cost. */
/*     sdnn_classer(idx<int> *classes, idx<double> *pr, int ini, int inj,  */
/* 		 parameter *prm); */

/*     virtual ~sdnn_classer(); */

/*     //! set the constant cost of the junk class to <c>. */
/*     //! the underlying parameter is given the value */
/*     //! (sqrt (* 2 <c>)), so <c> must be positive. */
/*     //! BE CAREFUL that the junk parameter of an sdnn-classer */
/*     //! is usually shared by an mmi-cost, changing one */
/*     //! will change the other. */
/*     void set_junk_cost(float c); */
/*     void fprop(state_idx<T> *in, sdnnclass_state *out); */
/*   }; */


/*   ////////////////////////////////////////////////////////////////////////////// */

/*   //! a module that takes an idx3 as input, runs it through */
/*   //! a machine, and runs the output of the machine through */
/*   //! a cost function whose second output is the desired label */
/*   //! stored in an idx0 of int. */
/*   template <class T> class sdnn_module */
/*   { */
/*   public: */
/*     net_cscscfe				&machine; */
/*     state_idx<T>			*mout; */
/*     sdnn_classer			&classifier; */

/*     sdnn_module(net_cscscfe &m, sdnn_classer &cl); */

/*     virtual ~sdnn_module(); */

/*     void fprop(state_idx<T> &input, sdnnclass_state &output); */
/*   }; */


} // end namespace ebl

#endif /* SDNN_MODULES_H_ */
